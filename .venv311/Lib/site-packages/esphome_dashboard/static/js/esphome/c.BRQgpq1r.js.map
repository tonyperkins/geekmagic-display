{"version":3,"file":"c.BRQgpq1r.js","sources":["../../../../node_modules/esptool-js/lib/targets/esp32s3.js"],"sourcesContent":["import { ROM } from \"./rom.js\";\nexport class ESP32S3ROM extends ROM {\n    constructor() {\n        super(...arguments);\n        this.CHIP_NAME = \"ESP32-S3\";\n        this.IMAGE_CHIP_ID = 9;\n        this.EFUSE_BASE = 0x60007000;\n        this.MAC_EFUSE_REG = this.EFUSE_BASE + 0x044;\n        this.EFUSE_BLOCK1_ADDR = this.EFUSE_BASE + 0x44;\n        this.EFUSE_BLOCK2_ADDR = this.EFUSE_BASE + 0x5c;\n        this.UART_CLKDIV_REG = 0x60000014;\n        this.UART_CLKDIV_MASK = 0xfffff;\n        this.UART_DATE_REG_ADDR = 0x60000080;\n        this.FLASH_WRITE_SIZE = 0x400;\n        this.BOOTLOADER_FLASH_OFFSET = 0x0;\n        this.FLASH_SIZES = {\n            \"1MB\": 0x00,\n            \"2MB\": 0x10,\n            \"4MB\": 0x20,\n            \"8MB\": 0x30,\n            \"16MB\": 0x40,\n        };\n        this.SPI_REG_BASE = 0x60002000;\n        this.SPI_USR_OFFS = 0x18;\n        this.SPI_USR1_OFFS = 0x1c;\n        this.SPI_USR2_OFFS = 0x20;\n        this.SPI_MOSI_DLEN_OFFS = 0x24;\n        this.SPI_MISO_DLEN_OFFS = 0x28;\n        this.SPI_W0_OFFS = 0x58;\n        this.USB_RAM_BLOCK = 0x800;\n        this.UARTDEV_BUF_NO_USB = 3;\n        this.UARTDEV_BUF_NO = 0x3fcef14c;\n    }\n    async getChipDescription(loader) {\n        const majorRev = await this.getMajorChipVersion(loader);\n        const minorRev = await this.getMinorChipVersion(loader);\n        const pkgVersion = await this.getPkgVersion(loader);\n        const chipName = {\n            0: \"ESP32-S3 (QFN56)\",\n            1: \"ESP32-S3-PICO-1 (LGA56)\",\n        };\n        return `${chipName[pkgVersion] || \"unknown ESP32-S3\"} (revision v${majorRev}.${minorRev})`;\n    }\n    async getPkgVersion(loader) {\n        const numWord = 3;\n        return ((await loader.readReg(this.EFUSE_BLOCK1_ADDR + 4 * numWord)) >> 21) & 0x07;\n    }\n    async getRawMinorChipVersion(loader) {\n        const hiNumWord = 5;\n        const hi = ((await loader.readReg(this.EFUSE_BLOCK1_ADDR + 4 * hiNumWord)) >> 23) & 0x01;\n        const lowNumWord = 3;\n        const low = ((await loader.readReg(this.EFUSE_BLOCK1_ADDR + 4 * lowNumWord)) >> 18) & 0x07;\n        return (hi << 3) + low;\n    }\n    async getMinorChipVersion(loader) {\n        const minorRaw = await this.getRawMinorChipVersion(loader);\n        if (await this.isEco0(loader, minorRaw)) {\n            return 0;\n        }\n        return this.getRawMinorChipVersion(loader);\n    }\n    async getRawMajorChipVersion(loader) {\n        const numWord = 5;\n        return ((await loader.readReg(this.EFUSE_BLOCK1_ADDR + 4 * numWord)) >> 24) & 0x03;\n    }\n    async getMajorChipVersion(loader) {\n        const minorRaw = await this.getRawMinorChipVersion(loader);\n        if (await this.isEco0(loader, minorRaw)) {\n            return 0;\n        }\n        return this.getRawMajorChipVersion(loader);\n    }\n    async getBlkVersionMajor(loader) {\n        const numWord = 4;\n        return ((await loader.readReg(this.EFUSE_BLOCK2_ADDR + 4 * numWord)) >> 0) & 0x03;\n    }\n    async getBlkVersionMinor(loader) {\n        const numWord = 3;\n        return ((await loader.readReg(this.EFUSE_BLOCK1_ADDR + 4 * numWord)) >> 24) & 0x07;\n    }\n    async isEco0(loader, minorRaw) {\n        // Workaround: The major version field was allocated to other purposes\n        // when block version is v1.1.\n        // Luckily only chip v0.0 have this kind of block version and efuse usage.\n        return ((minorRaw & 0x7) === 0 &&\n            (await this.getBlkVersionMajor(loader)) === 1 &&\n            (await this.getBlkVersionMinor(loader)) === 1);\n    }\n    async getFlashCap(loader) {\n        const numWord = 3;\n        const block1Addr = this.EFUSE_BASE + 0x044;\n        const addr = block1Addr + 4 * numWord;\n        const registerValue = await loader.readReg(addr);\n        const flashCap = (registerValue >> 27) & 0x07;\n        return flashCap;\n    }\n    async getFlashVendor(loader) {\n        const numWord = 4;\n        const block1Addr = this.EFUSE_BASE + 0x044;\n        const addr = block1Addr + 4 * numWord;\n        const registerValue = await loader.readReg(addr);\n        const vendorId = (registerValue >> 0) & 0x07;\n        const vendorMap = {\n            1: \"XMC\",\n            2: \"GD\",\n            3: \"FM\",\n            4: \"TT\",\n            5: \"BY\",\n        };\n        return vendorMap[vendorId] || \"\";\n    }\n    async getPsramCap(loader) {\n        const numWord = 4;\n        const block1Addr = this.EFUSE_BASE + 0x044;\n        const addr = block1Addr + 4 * numWord;\n        const registerValue = await loader.readReg(addr);\n        const psramCap = (registerValue >> 3) & 0x03;\n        return psramCap;\n    }\n    async getPsramVendor(loader) {\n        const numWord = 4;\n        const block1Addr = this.EFUSE_BASE + 0x044;\n        const addr = block1Addr + 4 * numWord;\n        const registerValue = await loader.readReg(addr);\n        const vendorId = (registerValue >> 7) & 0x03;\n        const vendorMap = {\n            1: \"AP_3v3\",\n            2: \"AP_1v8\",\n        };\n        return vendorMap[vendorId] || \"\";\n    }\n    async getChipFeatures(loader) {\n        const features = [\"Wi-Fi\", \"BLE\"];\n        const flashMap = {\n            0: null,\n            1: \"Embedded Flash 8MB\",\n            2: \"Embedded Flash 4MB\",\n        };\n        const flashCap = await this.getFlashCap(loader);\n        const flashVendor = await this.getFlashVendor(loader);\n        const flash = flashMap[flashCap];\n        const flashDescription = flash !== undefined ? flash : \"Unknown Embedded Flash\";\n        if (flash !== null) {\n            features.push(`${flashDescription} (${flashVendor})`);\n        }\n        const psramMap = {\n            0: null,\n            1: \"Embedded PSRAM 8MB\",\n            2: \"Embedded PSRAM 2MB\",\n        };\n        const psramCap = await this.getPsramCap(loader);\n        const psramVendor = await this.getPsramVendor(loader);\n        const psram = psramMap[psramCap];\n        const psramDescription = psram !== undefined ? psram : \"Unknown Embedded PSRAM\";\n        if (psram !== null) {\n            features.push(`${psramDescription} (${psramVendor})`);\n        }\n        return features;\n    }\n    async getCrystalFreq(loader) {\n        return 40;\n    }\n    _d2h(d) {\n        const h = (+d).toString(16);\n        return h.length === 1 ? \"0\" + h : h;\n    }\n    async postConnect(loader) {\n        const bufNo = (await loader.readReg(this.UARTDEV_BUF_NO)) & 0xff;\n        loader.debug(\"In _post_connect \" + bufNo);\n        if (bufNo == this.UARTDEV_BUF_NO_USB) {\n            loader.ESP_RAM_BLOCK = this.USB_RAM_BLOCK;\n        }\n    }\n    async readMac(loader) {\n        let mac0 = await loader.readReg(this.MAC_EFUSE_REG);\n        mac0 = mac0 >>> 0;\n        let mac1 = await loader.readReg(this.MAC_EFUSE_REG + 4);\n        mac1 = (mac1 >>> 0) & 0x0000ffff;\n        const mac = new Uint8Array(6);\n        mac[0] = (mac1 >> 8) & 0xff;\n        mac[1] = mac1 & 0xff;\n        mac[2] = (mac0 >> 24) & 0xff;\n        mac[3] = (mac0 >> 16) & 0xff;\n        mac[4] = (mac0 >> 8) & 0xff;\n        mac[5] = mac0 & 0xff;\n        return (this._d2h(mac[0]) +\n            \":\" +\n            this._d2h(mac[1]) +\n            \":\" +\n            this._d2h(mac[2]) +\n            \":\" +\n            this._d2h(mac[3]) +\n            \":\" +\n            this._d2h(mac[4]) +\n            \":\" +\n            this._d2h(mac[5]));\n    }\n    getEraseSize(offset, size) {\n        return size;\n    }\n}\n"],"names":["ESP32S3ROM","ROM","constructor","super","arguments","this","CHIP_NAME","IMAGE_CHIP_ID","EFUSE_BASE","MAC_EFUSE_REG","EFUSE_BLOCK1_ADDR","EFUSE_BLOCK2_ADDR","UART_CLKDIV_REG","UART_CLKDIV_MASK","UART_DATE_REG_ADDR","FLASH_WRITE_SIZE","BOOTLOADER_FLASH_OFFSET","FLASH_SIZES","SPI_REG_BASE","SPI_USR_OFFS","SPI_USR1_OFFS","SPI_USR2_OFFS","SPI_MOSI_DLEN_OFFS","SPI_MISO_DLEN_OFFS","SPI_W0_OFFS","USB_RAM_BLOCK","UARTDEV_BUF_NO_USB","UARTDEV_BUF_NO","getChipDescription","loader","majorRev","getMajorChipVersion","minorRev","getMinorChipVersion","getPkgVersion","readReg","getRawMinorChipVersion","minorRaw","isEco0","getRawMajorChipVersion","getBlkVersionMajor","getBlkVersionMinor","getFlashCap","addr","getFlashVendor","getPsramCap","getPsramVendor","getChipFeatures","features","flashCap","flashVendor","flash","flashDescription","undefined","push","psramCap","psramVendor","psram","psramDescription","getCrystalFreq","_d2h","d","h","toString","length","postConnect","bufNo","debug","ESP_RAM_BLOCK","readMac","mac0","mac1","mac","Uint8Array","getEraseSize","offset","size"],"mappings":"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","x_google_ignoreList":[0]}