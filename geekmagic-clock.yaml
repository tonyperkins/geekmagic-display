esphome:
  name: geekmagic-clock
  friendly_name: GeekMagic Clock
  on_boot:
    then:
      - delay: 1s
      - light.turn_on:
          id: back_light
          brightness: 70%
      - component.update: lcd_display

esp32:
  board: esp32dev
  framework:
    type: arduino

# Enable logging Test
logger:

# Enable Home Assistant API
api:
  encryption:
    key: "YgdW+qnE244n/+i4SyozBLNo9+DMI9SYHuFPPoswuwg="

ota:
  - platform: esphome
    password: "29f09ea72005368b01eb1231bdc562f2"

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: "Geekmagic-Clock Fallback Hotspot"
    password: "uewvtkFigvsI"

captive_portal:

# Backlight control
output:
  - platform: ledc
    pin: GPIO25
    inverted: true
    id: backlight_pwm

light:
  - platform: monochromatic
    output: backlight_pwm
    name: "Display Backlight"
    id: back_light
    restore_mode: ALWAYS_ON

# Persistent brightness level index (0..3)
globals:
  - id: bright_idx
    type: int
    restore_value: yes
    initial_value: '1'

# Touch sensor setup
esp32_touch:

binary_sensor:
  - platform: esp32_touch
    name: "Touch Button"
    id: touch_btn
    pin: GPIO32
    threshold: 1250
    on_press:
      then:
        - lambda: |-
            // Cycle brightness index 0..3
            id(bright_idx) = (id(bright_idx) + 1) & 0x3;
            float b = 1.0f;
            switch (id(bright_idx)) {
              case 0: b = 0.15f; break;
              case 1: b = 0.35f; break;
              case 2: b = 0.65f; break;
              default: b = 1.0f; break;
            }
            auto call = id(back_light).turn_on();
            call.set_brightness(b);
            call.perform();

# SPI configuration for your actual hardware
spi:
  clk_pin: GPIO18
  mosi_pin: GPIO23  # Your hardware uses GPIO23, not GPIO19
  id: spihwd

# Display configuration for your actual display
display:
  - platform: ili9xxx
    model: st7789v
    spi_id: spihwd
    data_rate: 40MHz
    dc_pin: GPIO02
    reset_pin: GPIO04
    spi_mode: MODE3
    dimensions:
      width: 240      # Display is 240x240
      height: 240
      offset_height: 0
      offset_width: 0
    invert_colors: true
    color_order: bgr
    color_palette: 8BIT
    auto_clear_enabled: true
    update_interval: 100ms
    id: lcd_display
    lambda: |-
      it.fill(Color::BLACK);
      auto now = id(homeassistant_time).now();

      if (now.is_valid()) {
        // Digital time at the top
        it.strftime(120, 5, id(time_font), Color::WHITE, TextAlign::TOP_CENTER, "%H:%M", now);

        // Weather Information
        int y_start = 100;
        int line_height = 40;

        // Temperature (left/right aligned with icons)
        if (id(outdoor_temperature).has_state() && id(feels_like_temperature).has_state()) {
          int ty = y_start;

          // Left: Actual temperature, thermometer icon
          int left_icon_x = 26;   // left margin for icon
          it.filled_circle(left_icon_x, ty + 6, 4, Color::WHITE);   // bulb
          it.line(left_icon_x, ty - 6, left_icon_x, ty + 4, Color::WHITE); // tube
          it.rectangle(left_icon_x - 2, ty - 10, 4, 12, Color::WHITE);
          // Font sizes available: tiny, small, medium, large, giant
          it.printf(left_icon_x + 14, ty, id(medium_font), Color::WHITE, TextAlign::CENTER_LEFT, "%.1f°", id(outdoor_temperature).state);

          // Right: Feels like, sun with rays (icon centered with number)
          int right_icon_x = 142;                      // right margin for icon
          int sun_cx = right_icon_x - 4;              // icon centered with value
          it.circle(sun_cx, ty + 1, 4, Color::WHITE);  // align icon vertically with text
          for (int i = 0; i < 8; i++) {
            float a = i * (M_PI/4.0f);
            int x1 = sun_cx + (int)(5 * cos(a));       // slightly shorter rays
            int y1 = ty + (int)(5 * sin(a));
            int x2 = sun_cx + (int)(8 * cos(a));
            int y2 = ty + (int)(8 * sin(a));
            it.line(x1, y1, x2, y2, Color::WHITE);
          }
          it.printf(right_icon_x + 14, ty, id(medium_font), Color::WHITE, TextAlign::CENTER_LEFT, "%.1f°", id(feels_like_temperature).state);
        }

        // Wind
        if (id(wind_speed).has_state() && id(wind_gust).has_state() && id(wind_direction).has_state()) {
          // Display wind speed and gust with icons (no separator)
          int wy = y_start + line_height;
          // speed icon: streamlines
          int speed_icon_x = 20;
          it.line(speed_icon_x,     wy - 5, speed_icon_x + 10, wy - 5, Color::WHITE);
          it.line(speed_icon_x + 2, wy,     speed_icon_x + 12, wy,     Color::WHITE);
          it.line(speed_icon_x,     wy + 5, speed_icon_x + 10, wy + 5, Color::WHITE);
          // columns for values and units (fixed x to avoid overlap with variable digit widths)
          int speed_val_x = 45;   // bring value close to icon
          int speed_mph_x = 65;   // mph right after value
          it.printf(speed_val_x, wy, id(medium_font), Color::WHITE, TextAlign::CENTER_LEFT, "%.0f", id(wind_speed).state);
          it.printf(speed_mph_x, wy+2, id(tiny_font),   Color::WHITE, TextAlign::CENTER_LEFT, "mph");

          // gust icon: small flag
          int gx = 118;           // gust icon start
          it.line(gx, wy - 6, gx, wy + 6, Color::WHITE); // pole
          it.line(gx, wy - 6, gx + 10, wy - 2, Color::WHITE);
          it.line(gx + 10, wy - 2, gx, wy + 2, Color::WHITE);
          it.line(gx, wy + 2, gx, wy - 6, Color::WHITE);
          int gust_val_x = 137;   // bring value close to flag icon
          int gust_mph_x = 157;   // mph right after value
          it.printf(gust_val_x, wy, id(medium_font), Color::WHITE, TextAlign::CENTER_LEFT, "%.0f", id(wind_gust).state);
          it.printf(gust_mph_x, wy+2, id(tiny_font),   Color::WHITE, TextAlign::CENTER_LEFT, "mph");

          // Draw wind flow arrow (sensor reports FROM direction; arrow shows TO/flow)
          float dir_from_deg = id(wind_direction).state;
          float flow_deg = fmodf(dir_from_deg + 180.0f, 360.0f);  // flip 180° to get flow direction
          float ang = (flow_deg - 90.0f) * M_PI / 180.0f;         // screen coordinates adjustment

          int center_x = 200;     // minor nudge
          int center_y = y_start + line_height;
          // Draw surrounding circle like a compass
          int compass_r = 13;     // slightly larger
          it.circle(center_x, center_y, compass_r, Color::WHITE);

          // Solid triangular pointer inside the circle
          int radius = 13;               // where the tip should be
          int end_x = center_x + (int)(radius * cos(ang));
          int end_y = center_y + (int)(radius * sin(ang));
          int head_len = 9;
          int head_w   = 9;
          int bx = end_x - (int)(head_len * cos(ang));
          int by = end_y - (int)(head_len * sin(ang));
          int lx = bx + (int)((head_w/2.0f) * -sin(ang));
          int ly = by + (int)((head_w/2.0f) *  cos(ang));
          int rx = bx - (int)((head_w/2.0f) * -sin(ang));
          int ry = by - (int)((head_w/2.0f) *  cos(ang));
          it.filled_triangle(end_x, end_y, lx, ly, rx, ry, Color::WHITE);
          // arrow shaft from center to base of the triangle for a longer line
          it.line(center_x, center_y, bx, by, Color::WHITE);
        }

        // Humidity
        if (id(humidity).has_state()) {
          // Full-width humidity row: icon (left), wide bar (middle), percent (right)
          int bar_height = 20;
          int bar_y = y_start + 2 * line_height - (bar_height/2);
          float percentage = id(humidity).state / 100.0;
          // icon
          int icon_cx = 28;
          int icon_cy = bar_y + bar_height/2;
          it.filled_circle(icon_cx, icon_cy + 2, 6, Color::WHITE);
          it.filled_triangle(icon_cx, icon_cy - 8, icon_cx - 5, icon_cy + 1, icon_cx + 5, icon_cy + 1, Color::WHITE);
          // percent value at far right
          int pct_x = 222; // right margin anchor
          it.printf(pct_x, y_start + 2 * line_height, id(medium_font), Color::WHITE, TextAlign::CENTER_RIGHT, "%.0f%%", id(humidity).state);
          // bar spans from left of center to just before percent
          int bar_x = 48;
          int bar_right = 160;
          int bar_width = bar_right - bar_x;
          it.rectangle(bar_x, bar_y, bar_width, bar_height, Color::WHITE);
          it.filled_rectangle(bar_x, bar_y, (int)(bar_width * percentage), bar_height, Color::WHITE);
        }

      } else {
        it.printf(120, 120, id(roboto_font), Color::WHITE, TextAlign::CENTER, "Waiting for time...");
      }

      // Optional message at the bottom
      if (id(display_message).has_state() && !id(display_message).state.empty()) {
        it.printf(120, 220, id(small_font), Color(200, 200, 200), TextAlign::CENTER, "%s", id(display_message).state.c_str());
      }

# Fonts
font:
  - file: "gfonts://Roboto"
    id: roboto_font
    size: 18
  - file: "gfonts://Roboto"
    id: small_font
    size: 14
  - file: "gfonts://Roboto"
    id: tiny_font
    size: 11
  - file: "gfonts://Roboto"
    id: medium_font
    size: 28
  - file: "gfonts://Roboto@700"
    id: time_font
    size: 64

# Time component
time:
  - platform: homeassistant
    id: homeassistant_time
    timezone: America/Chicago
    on_time_sync:
      then:
        - component.update: lcd_display
    on_time:
      - seconds: /1
        then:
          - component.update: lcd_display

# Text sensor to receive messages from Home Assistant
text_sensor:
  - platform: homeassistant
    name: "Display Message"
    id: display_message
    entity_id: input_text.geekmagic_display_message
    on_value:
      then:
        - component.update: lcd_display

sensor:
  - platform: homeassistant
    id: outdoor_temperature
    entity_id: sensor.gw1200b_outdoor_temperature
    on_value:
      then:
        - component.update: lcd_display
  - platform: homeassistant
    id: feels_like_temperature
    entity_id: sensor.gw1200b_feels_like_temperature
    on_value:
      then:
        - component.update: lcd_display
  - platform: homeassistant
    id: wind_speed
    entity_id: sensor.gw1200b_wind_speed
    on_value:
      then:
        - component.update: lcd_display
  - platform: homeassistant
    id: wind_gust
    entity_id: sensor.gw1200b_wind_gust
    on_value:
      then:
        - component.update: lcd_display
  - platform: homeassistant
    id: humidity
    entity_id: sensor.gw1200b_humidity
    on_value:
      then:
        - component.update: lcd_display
  - platform: homeassistant
    id: wind_direction
    entity_id: sensor.gw1200b_wind_direction
    on_value:
      then:
        - component.update: lcd_display